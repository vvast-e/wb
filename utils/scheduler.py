from datetime import datetime, timedelta
import os

from apscheduler.schedulers.asyncio import AsyncIOScheduler
from sqlalchemy.ext.asyncio import AsyncSession
from apscheduler.executors.asyncio import AsyncIOExecutor

from crud import task as task_crud
from crud.history import update_history_status
from utils.wb_api import WBAPIClient, WBApiResponse
from crud.user import get_all_users, get_decrypted_wb_key
from crud.analytics import parse_shop_feedbacks_crud
from utils.aspect_processor import AspectProcessor
from database import AsyncSessionLocal

scheduler = AsyncIOScheduler(executors={'default': AsyncIOExecutor()})


async def get_db_session() -> AsyncSession:
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–µ—Å—Å–∏–∏ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞"""
    async with AsyncSessionLocal() as session:
        return session


async def _get_wb_api_key_for_task(db: AsyncSession, task_id: int) -> str:
    task = await task_crud.get_task_by_id(db, task_id)
    if not task or not task.owner:
        raise ValueError("Task or user not found")

    if not task.brand:
        raise ValueError("Brand not specified in task")

    # –ò—Å–ø–æ–ª—å–∑—É–µ–º get_decrypted_wb_key –Ω–∞–ø—Ä—è–º—É—é –≤–º–µ—Å—Ç–æ get_wb_api_key —Å Depends
    wb_api_key = await get_decrypted_wb_key(db, task.owner, task.brand)
    return wb_api_key


async def process_scheduled_tasks():
    db = await get_db_session()
    try:
        tasks = await task_crud.get_pending_tasks(db)
        for task in tasks:
            try:
                wb_api_key = await _get_wb_api_key_for_task(db, task.id)

                task.status = 'processing'
                await db.commit()
                wb_client = WBAPIClient(api_key=wb_api_key)

                if task.action == 'update_content':
                    result = await wb_client.update_card_content(task.nm_id, task.payload)
                    print()
                    print(result)
                elif task.action == 'update_media':
                    result = await wb_client.upload_meda(task.nm_id, task.payload.get("media"))
                    print()
                    print(result)
                elif task.action == 'upload_media_file':
                    if task.payload.get("immediate"):
                        # –ù–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞–µ–º, –∑–∞–¥–∞—á–∞ —É–∂–µ –±—ã–ª–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞ —Å—Ä–∞–∑—É
                        result = WBApiResponse(success=True, data={"info": "already uploaded"})
                    else:
                        file_path = task.payload.get("file_path")
                        if not file_path or not os.path.exists(file_path):
                            result = WBApiResponse(success=False, error="–§–∞–π–ª –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω")
                        else:
                            with open(file_path, "rb") as f:
                                file_data = f.read()
                            result = await wb_client.upload_mediaFile(
                                nm_id=task.nm_id,
                                file_data=file_data,
                                photo_number=task.payload["photo_number"],
                                media_type=task.payload.get("media_type", "image")
                            )
                            if result.success:
                                try:
                                    os.remove(file_path)
                                except Exception as e:
                                    print(f"[Scheduler] –ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª: {e}")
                                # –£–¥–∞–ª—è–µ–º –∑–∞–¥–∞—á—É –∏–∑ –±–∞–∑—ã –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–π –æ—Ç–ø—Ä–∞–≤–∫–∏ –∏ —É–¥–∞–ª–µ–Ω–∏—è —Ñ–∞–π–ª–∞
                                await db.delete(task)
                                await db.commit()
                print(result.success)
                if result.success:
                    task.status = 'completed'
                    await update_history_status(db, status='completed', user_id=task.user_id, created_at=task.created_at)
                else:
                    print(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–∫–∞—Ç–µ –∏–∑–º–µ–Ω–µ–Ω–∏–π: {result.error}")
                    print(f"üßæ –û—Ç–≤–µ—Ç WB: {result.wb_response}")
                    task.status = 'pending'
                    task.scheduled_at = datetime.now() + timedelta(minutes=5)
                    if hasattr(result, 'error'):
                        task.error = result.error
                    elif isinstance(result.wb_response, dict) and 'error' in result.wb_response:
                        task.error = result.wb_response['error']
                    else:
                        task.error = "Unknown error"

                task.wb_response = result.wb_response

            except Exception as e:
                task.status = 'pending'
                task.scheduled_at = datetime.now() + timedelta(minutes=5)
                task.error = str(e)

        await db.commit()
    finally:
        await db.close()


async def parse_all_shops_feedbacks():
    print(f"[SCHEDULER] >>> –ó–∞–ø—É—Å–∫ –ø–∞—Ä—Å–µ—Ä–∞ –æ—Ç–∑—ã–≤–æ–≤: {datetime.now().isoformat()}")
    db = await get_db_session()
    try:
        users = await get_all_users(db)
        print(f"[SCHEDULER] –ù–∞–π–¥–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {len(users)}")
        for user in users:
            if not user.wb_api_key:
                print(f"[SCHEDULER] –ü—Ä–æ–ø—É—â–µ–Ω user_id={user.id} (–Ω–µ—Ç wb_api_key)")
                continue
            for brand in (user.wb_api_key or {}).keys():
                try:
                    print(f"[SCHEDULER] –ü–∞—Ä—Å–∏–º –æ—Ç–∑—ã–≤—ã –¥–ª—è user_id={user.id}, brand={brand}, –≤—Ä–µ–º—è: {datetime.now().isoformat()}")
                    await parse_shop_feedbacks_crud(db, user.id, brand, max_count_per_product=1000, save_to_db=True)
                    print(f"[SCHEDULER] –£—Å–ø–µ—à–Ω–æ: user_id={user.id}, brand={brand}")
                except Exception as e:
                    print(f"[SCHEDULER] –û—à–∏–±–∫–∞: user_id={user.id}, brand={brand}, error={e}")
    finally:
        await db.close()
    print(f"[SCHEDULER] <<< –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –ø–∞—Ä—Å–µ—Ä–∞ –æ—Ç–∑—ã–≤–æ–≤: {datetime.now().isoformat()}")


async def analyze_all_new_feedbacks():
    """–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑ –≤—Å–µ—Ö –Ω–æ–≤—ã—Ö –æ—Ç–∑—ã–≤–æ–≤ –±–µ–∑ –∞—Å–ø–µ–∫—Ç–æ–≤"""
    print(f"[SCHEDULER] >>> –ó–∞–ø—É—Å–∫ –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä–∞ –∞—Å–ø–µ–∫—Ç–æ–≤: {datetime.now().isoformat()}")
    
    db = await get_db_session()
    try:
        # –°–æ–∑–¥–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä –∞—Å–ø–µ–∫—Ç–æ–≤
        aspect_processor = AspectProcessor(db)
        
        print(f"[SCHEDULER] üîç –ü–æ–∏—Å–∫ –Ω–æ–≤—ã—Ö –æ—Ç–∑—ã–≤–æ–≤ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞...")
        
        # –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ –∞—Å–ø–µ–∫—Ç–∞–º
        stats = await aspect_processor.get_aspect_statistics()
        print(f"[SCHEDULER] üìä –¢–µ–∫—É—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞: {stats.get('total_aspects', 0)} –∞—Å–ø–µ–∫—Ç–æ–≤ –≤ –ë–î")
        
        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤—Å–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –æ—Ç–∑—ã–≤—ã –±–µ–∑ –∞—Å–ø–µ–∫—Ç–æ–≤
        result = await aspect_processor.process_existing_feedbacks(limit=1000)
        
        processed = result.get('processed', 0)
        new_aspects = result.get('new_aspects', 0)
        skipped = result.get('skipped_already_analyzed', 0)
        
        print(f"[SCHEDULER] ‚úÖ –ê–Ω–∞–ª–∏–∑ –∑–∞–≤–µ—Ä—à–µ–Ω:")
        print(f"[SCHEDULER]    –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ –æ—Ç–∑—ã–≤–æ–≤: {processed}")
        print(f"[SCHEDULER]    –°–æ–∑–¥–∞–Ω–æ –Ω–æ–≤—ã—Ö –∞—Å–ø–µ–∫—Ç–æ–≤: {new_aspects}")
        print(f"[SCHEDULER]    –ü—Ä–æ–ø—É—â–µ–Ω–æ —É–∂–µ –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö: {skipped}")
        
        if processed > 0:
            print(f"[SCHEDULER] üéØ –£—Å–ø–µ—à–Ω–æ –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–æ {processed} –Ω–æ–≤—ã—Ö –æ—Ç–∑—ã–≤–æ–≤")
        else:
            print(f"[SCHEDULER] ‚ÑπÔ∏è  –ù–æ–≤—ã—Ö –æ—Ç–∑—ã–≤–æ–≤ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ")
            
    except Exception as e:
        print(f"[SCHEDULER] ‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∞–Ω–∞–ª–∏–∑–µ –∞—Å–ø–µ–∫—Ç–æ–≤: {e}")
        import traceback
        traceback.print_exc()
    finally:
        await db.close()
    
    print(f"[SCHEDULER] <<< –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä–∞ –∞—Å–ø–µ–∫—Ç–æ–≤: {datetime.now().isoformat()}")


def start_scheduler():
    # –ó–∞–¥–∞—á–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∑–∞–¥–∞—á (–∫–∞–∂–¥—ã–µ 5 —Å–µ–∫—É–Ω–¥)
    scheduler.add_job(
        process_scheduled_tasks,
        'interval',
        seconds=5,
        max_instances=20,
        timezone='Europe/Moscow'
    )
    
    # –ó–∞–¥–∞—á–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –æ—Ç–∑—ã–≤–æ–≤ –≤—Å–µ—Ö –º–∞–≥–∞–∑–∏–Ω–æ–≤ (–∫–∞–∂–¥—ã–µ 30 –º–∏–Ω—É—Ç)
    scheduler.add_job(
        parse_all_shops_feedbacks,
        'interval',
        minutes=30,
        max_instances=1,
        timezone='Europe/Moscow'
    )
    
    # –ó–∞–¥–∞—á–∞ –∞–Ω–∞–ª–∏–∑–∞ –∞—Å–ø–µ–∫—Ç–æ–≤ (–∫–∞–∂–¥—ã–µ 32 –º–∏–Ω—É—Ç—ã - —á–µ—Ä–µ–∑ 2 –º–∏–Ω—É—Ç—ã –ø–æ—Å–ª–µ –ø–∞—Ä—Å–µ—Ä–∞)
    scheduler.add_job(
        analyze_all_new_feedbacks,
        'interval',
        minutes=32,
        max_instances=1,
        timezone='Europe/Moscow'
    )
    
    print("[SCHEDULER] üöÄ –ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –∑–∞–ø—É—â–µ–Ω:")
    print("[SCHEDULER]    üìù –ü–∞—Ä—Å–µ—Ä –æ—Ç–∑—ã–≤–æ–≤: –∫–∞–∂–¥—ã–µ 30 –º–∏–Ω—É—Ç")
    print("[SCHEDULER]    ü§ñ –ê–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä –∞—Å–ø–µ–∫—Ç–æ–≤: –∫–∞–∂–¥—ã–µ 32 –º–∏–Ω—É—Ç—ã (—á–µ—Ä–µ–∑ 2 –º–∏–Ω –ø–æ—Å–ª–µ –ø–∞—Ä—Å–µ—Ä–∞)")
    print("[SCHEDULER]    ‚öôÔ∏è  –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–¥–∞—á: –∫–∞–∂–¥—ã–µ 5 —Å–µ–∫—É–Ω–¥")
    
    scheduler.start()